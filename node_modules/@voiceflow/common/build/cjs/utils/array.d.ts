import { AnyRecord, ArrayUnionToIntersection, PrimitiveMap } from "../types";
export declare const unique: <T>(items: T[]) => T[];
export declare const without: <T>(items: T[], index: number) => T[];
export declare const withoutValue: <T>(items: T[], value: T) => T[];
export declare const withoutValues: <T>(items: T[], values: T[]) => T[];
export declare const replace: <T>(items: T[], index: number, item: T) => T[];
export declare const insert: <T>(items: T[], index: number, item: T) => T[];
export declare const insertAll: <T>(items: T[], index: number, additionalItems: T[]) => T[];
export declare const append: <T>(items: T[], item: T) => T[];
export declare const toggleMembership: <T>(items: T[], item: T) => T[];
export declare const head: <T>(items: T[]) => [T, T[]];
export declare const tail: <T>(items: T[]) => [T[], T];
export declare const reorder: <T>(items: T[], fromIndex: number, toIndex: number) => T[];
export declare const separate: <T>(items: T[], predicate: (item: T, index: number) => boolean) => [T[], T[]];
interface CreateEntries {
    <T extends PropertyKey>(array: readonly T[]): Array<readonly [T, T]>;
    <T extends AnyRecord, K extends PropertyKey = string>(array: readonly T[], getKey: (value: T) => K): Array<readonly [K, T]>;
}
interface CreateMap {
    <T extends PropertyKey>(array: readonly T[]): PrimitiveMap<T>;
    <T extends AnyRecord, K extends PropertyKey = string>(array: readonly T[], getKey: (value: T) => K): Record<K, T>;
}
export declare const createEntries: CreateEntries;
export declare const createMap: CreateMap;
export declare const findUnion: <T>(lhs: T[], rhs: T[]) => {
    rhsOnly: T[];
    lhsOnly: T[];
    union: T[];
};
export declare const diff: <T>(lhs: T[], rhs: T[]) => T[];
export declare const hasIdenticalMembers: <T>(lhs: T[], rhs: T[]) => boolean;
export declare const asyncForEach: <T>(array: T[], callback: (item: T, index: number, array: T[]) => Promise<void>) => Promise<void>;
export declare const isNullish: (value: unknown) => value is unknown;
export declare const isNotNullish: <T>(value: T) => value is NonNullable<T>;
/** @deprecated Use `array.filter(isNotNullish)` instead. */
export declare const filterOutNullish: <T>(items: readonly T[]) => NonNullable<T>[];
export declare const filterAndGetLastRemovedValue: <T>(list: T[], filter: (item: T) => boolean) => [T[], T | null];
export declare const inferUnion: <T extends ArrayLike<unknown>>(array: T) => import("../types").SafeArray<T[number], T>;
export declare const toArray: <T>(valueOrArray: T | T[]) => T[];
/**
 * Merge together two arrays, if two items have the same identity based on the {@link identify} function
 * they will be merged together using the {@link merge} function provided.
 * @param items Array of items as a starting base.
 * @param newItems Array of items to merge in.
 * @param identify Function returning how to identify an item in the array
 * @param merge Function given two matching item identifiers, returning a single merged result
 * @example
 * const existingItems = [{a: 1, b: [1, 2, 3]}, {a: 2, b: [4]}];
 * const newItems = [{a: 1, b: [5]}, {a: 3, b: [6, 7]}];
 *
 * const items = mergeByIdentifier(
 *   existingItems,
 *   newItems,
 *   (item) => item.a,
 *   (existingItem, newItem) => {
 *     return {
 *       ...existingItem,
 *       b: [...existingItem.b, ...newItem.b]
 *     }
 *   }
 * );
 *
 * items == [{a: 1, b: [1, 2, 3, 5]}, {a: 2, b: [4]}, {a: 3, b: [6, 7]}];
 */
export declare const mergeByIdentifier: <T>(items: T[], newItems: T[], identify: (item: T, index: number) => string, merge: (item1: T, item2: T) => T) => T[];
export {};
