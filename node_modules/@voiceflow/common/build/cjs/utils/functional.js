"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withEffect = exports.chainVoidAsync = exports.chainAsync = exports.chainVoid = exports.chain = exports.stringify = exports.identity = exports.noop = exports.compose = exports.isFunction = void 0;
const isFunction = (value) => typeof value === 'function';
exports.isFunction = isFunction;
const compose = (...transforms) => (value) => {
    if (transforms.length === 1) {
        return transforms[0](value);
    }
    if (transforms.length === 2) {
        return transforms[0](transforms[1](value));
    }
    return transforms.reduceRight((acc, transform) => transform(acc), value);
};
exports.compose = compose;
const noop = () => undefined;
exports.noop = noop;
const identity = (value) => value;
exports.identity = identity;
const stringify = (value) => (typeof value === 'string' ? value : String(value));
exports.stringify = stringify;
const chain = (...fns) => (...args) => {
    var _a, _b, _c;
    // perf optimization, most of the time we have one or two functions
    if (fns.length === 1) {
        (_a = fns[0]) === null || _a === void 0 ? void 0 : _a.call(fns, ...args);
    }
    else if (fns.length === 2) {
        (_b = fns[0]) === null || _b === void 0 ? void 0 : _b.call(fns, ...args);
        (_c = fns[1]) === null || _c === void 0 ? void 0 : _c.call(fns, ...args);
    }
    else {
        fns.forEach((fn) => fn === null || fn === void 0 ? void 0 : fn(...args));
    }
};
exports.chain = chain;
const chainVoid = (...fns) => () => (0, exports.chain)(...fns)();
exports.chainVoid = chainVoid;
const chainAsync = (...fns) => async (...args) => {
    var _a, _b, _c;
    // perf optimization, most of the time we have one or two functions
    if (fns.length === 1) {
        await ((_a = fns[0]) === null || _a === void 0 ? void 0 : _a.call(fns, ...args));
    }
    else if (fns.length === 2) {
        await ((_b = fns[0]) === null || _b === void 0 ? void 0 : _b.call(fns, ...args));
        await ((_c = fns[1]) === null || _c === void 0 ? void 0 : _c.call(fns, ...args));
    }
    else {
        // eslint-disable-next-line no-restricted-syntax
        for (const fn of fns) {
            // eslint-disable-next-line no-await-in-loop
            await (fn === null || fn === void 0 ? void 0 : fn(...args));
        }
    }
};
exports.chainAsync = chainAsync;
const chainVoidAsync = (...fns) => () => (0, exports.chainAsync)(...fns)();
exports.chainVoidAsync = chainVoidAsync;
const withEffect = (callback) => (value) => {
    callback(value);
    return value;
};
exports.withEffect = withEffect;
//# sourceMappingURL=functional.js.map