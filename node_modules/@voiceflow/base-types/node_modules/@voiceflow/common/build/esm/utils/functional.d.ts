import { Nullish } from '../types';
export declare const isFunction: <T extends (...args: any[]) => any = (...args: any[]) => any>(value: unknown) => value is T;
export declare type Transform<T = any, R = T> = (value: T) => R;
export interface Compose {
    <R, T1>(t0: Transform<T1, R>): (value: T1) => R;
    <R, T1, T2>(t0: Transform<T1, T2>, t1: Transform<T2, R>): (value: T1) => R;
    <R, T1, T2, T3>(t0: Transform<T1, T2>, t1: Transform<T2, T3>, t2: Transform<T3, R>): (value: T1) => R;
    <R, T1, T2, T3, T4>(t0: Transform<T1, T2>, t1: Transform<T2, T3>, t2: Transform<T3, T4>, t3: Transform<T4, R>): (value: T1) => R;
    <R, T1, T2, T3, T4, T5>(t0: Transform<T1, T2>, t1: Transform<T2, T3>, t2: Transform<T3, T4>, t3: Transform<T4, T5>, t4: Transform<T5, R>): (value: T1) => R;
    <R, T1, T2, T3, T4, T5, T6>(t0: Transform<T1, T2>, t1: Transform<T2, T3>, t2: Transform<T3, T4>, t3: Transform<T4, T5>, t4: Transform<T5, T6>, t5: Transform<T6, R>): (value: T1) => R;
    (...transforms: Transform[]): <T extends object>(value: T) => T;
}
export declare const compose: Compose;
export declare type VoidFunction = () => void;
export declare const noop: VoidFunction;
export declare const identity: <T>(value: T) => T;
export declare const stringify: (value: any) => string;
declare type ChainCallback<A extends any[]> = (...args: A) => void;
export declare const chain: <A extends any[]>(fns_0: Nullish<ChainCallback<A>>, ...fns_1: Nullish<ChainCallback<A>>[]) => (...args: A) => void;
export declare const chainVoid: (fns_0: Nullish<VoidFunction>, ...fns_1: Nullish<VoidFunction>[]) => () => void;
export declare const chainAsync: <A extends any[]>(fns_0: Nullish<ChainCallback<A>>, ...fns_1: Nullish<ChainCallback<A>>[]) => (...args: A) => Promise<void>;
export declare const chainVoidAsync: (fns_0: Nullish<VoidFunction>, ...fns_1: Nullish<VoidFunction>[]) => () => Promise<void>;
export declare const withEffect: <T>(callback: (value: T) => void) => (value: T) => T;
export {};
