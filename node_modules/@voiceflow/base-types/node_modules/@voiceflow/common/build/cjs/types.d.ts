export declare type Nullable<T> = T | null;
export declare type Nullish<T = unknown> = Nullable<T> | undefined;
export declare type Function<A extends any[] = any[], R = any> = (...args: A) => R;
export declare type AnyFunction = Function<any[], any>;
export declare type Callback = Function<[], Eventual<void>>;
export declare type Eventual<T> = Promise<T> | T;
export declare type StringifyEnum<T extends string> = T | `${T}`;
export declare type NormalizedValue<T> = T extends Normalized<infer R> ? R : never;
export interface Normalized<T> {
    byKey: Record<string, T>;
    allKeys: string[];
}
export declare type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export declare type WithRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;
export declare type Writeable<T> = {
    -readonly [P in keyof T]: T[P];
};
export declare type PartialRecord<K extends PropertyKey, T> = Partial<Record<K, T>>;
export declare type NullableRecord<T> = {
    [K in keyof T]: Nullable<T[K]>;
};
export declare type NonNullishRecord<T> = Required<{
    [K in keyof T]: NonNullable<T[K]>;
}>;
export declare type Struct = Record<string, unknown>;
export declare type AnyRecord = Record<string, any>;
export declare type DeepPartial<T> = {
    [P in keyof T]?: T extends object ? DeepPartial<T[P]> : T;
};
/**
 * An object with no keys or values.
 * @see https://github.com/typescript-eslint/typescript-eslint/issues/2063#issuecomment-675156492
 */
export declare type EmptyObject = Record<never, never>;
/** Avoids accidentally converting an immutable array type to a mutable one. */
export declare type SafeArray<Element, Original> = Original extends Array<Element> ? Element[] : Original extends ReadonlyArray<Element> ? ReadonlyArray<Element> : Original extends ArrayLike<Element> ? ArrayLike<Element> : never;
export declare type ArrayUnionToIntersection<T extends ArrayLike<unknown>> = SafeArray<T[number], T>;
export declare type PrimitiveMap<T extends PropertyKey> = {
    [P in T]: P;
};
export declare type Join<T extends any[]> = T extends [AnyRecord, ...infer R] ? T[0] & Join<R> : {};
export declare type Tuple<T1, T2> = [T1, T2];
export declare type TupleFirst<T> = T extends Tuple<infer R, any> ? R : never;
export declare type TupleSecond<T> = T extends Tuple<any, infer R> ? R : never;
export declare type Pair<T> = Tuple<T, T>;
